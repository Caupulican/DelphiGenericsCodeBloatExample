# Delphi Generics Code Bloat Example

This example demonstrates how code bloat happens when using base classes from the generics collections. This issue affects the compiling and linking performance, since the code bloat generated by the generics is present only in those two stages, making the software development cycle exponentially slower.

This exemplifies what is discussed in one of the topics from a post in the [Marco Cantu blog](https://blog.marcocantu.com/blog/2022-december-suggestions-help-delphi-compiler.html):

> Delphi type system (like the classic Turbo Pascal one) is based on
> type declaration equivalence. In other words, even if two types have
> the same name and the same structure, they are different if declared
> in different units. If you assign a variable of type MyUnit1.TMyType
> to a variable of type MyUnit2.TMyType, you get a compiler error,
> regardless of the fact the two types have the same identical
> structure.
> 
> The only exception to this rule is for generic types. If you declare a
> variable of type TList<string> you are also creating an implicit type,
> TList<string>, based on the generic type TList<T>. You can have
> multiple type instances declared in different units and all matching
> the TList<string> signature and the compiler considers them compatible
> and allows you to assign them one to the other.
> 
> What happens behind the scenes, though, is that the compiler generates
> a new temporary type of each of the occurrences in different units. So
> you'll have, say, TList<string> in MyUnt1 (with a temporary type name)
> and TList<string> in MyUnit2 (with a different temporary name). For
> each of these types, the compiler creates instances for the generic
> type but also for each of the generic methods of the generic type.
> With a large amount of complex generic types (inherited and nested),
> this can take a significant effort by the compiler.
> 
> The solution to this issue is not to stop using generics, but to
> create shared instances of generic types whenever possible.
 
More can be found here:
 

 - [Do generic instantiations in multiple units bloat the executable?](https://stackoverflow.com/questions/31684300/do-generic-instantiations-in-multiple-units-bloat-the-executable)
 -  [Be aware of the “Growth by Generics”](https://support.embarcadero.com/article/44279)

I'm sure there are more places to find more information about this. However, I think these three make the matter quite clear already.

# Steps

 1. Open the **GenerateBloatTest** project 
 2. Generate the test project containing the example
 3. Make experiments :)
